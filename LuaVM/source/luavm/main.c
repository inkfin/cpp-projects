#include <lauxlib.h>
#include <lualib.h>
#include <stdio.h>
#include <stdlib.h>

#define SCRIPT_ROOT "./scripts/"

static lua_State* g_L = NULL;

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char* pname, const char* msg) {
    if (pname) lua_writestringerror("%s: ", pname);
    lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report(lua_State* L, int status) {
    if (status != LUA_OK) {
        const char* msg = lua_tostring(L, -1);
        l_message(NULL, msg);
        lua_pop(L, 1); /* remove message */
    }
    return status;
}

/*
** return 1 if success, 0 if failed
*/
int CheckLua(lua_State* L, int res) {
    if (res != LUA_OK) {
        const char* errMsg = lua_tostring(L, -1);  // Get the error message
        fprintf(stderr, "Error: %s\n", errMsg);    // Print the error message
        lua_pop(L, 1);                             // Remove the error message from the stack
        return 0;
    }
    return 1;
}

int main(int argc, char* argv[]) {
    g_L = luaL_newstate();
    if (g_L == NULL) {
        l_message(NULL, "cannot create state");
        return EXIT_FAILURE;
    }
    luaL_openlibs(g_L);  // Load the standard libraries

    if (CheckLua(g_L, luaL_dofile(g_L, SCRIPT_ROOT "test.lua"))) {
        // Successfully executed the command
        lua_getglobal(g_L, "a");  // Get the value of 'a' from the Lua state
        if (lua_isnumber(g_L, -1)) {
            float a = (float)lua_tonumber(g_L, -1);
            fprintf(stdout, "a = %f\n", a);  // Print the value of 'a'
        } else {
            fprintf(stderr, "Error: 'a' is not a number\n");
        }
    }

#ifdef _WIN32
    system("pause");  // Pause the system (Windows specific)
#endif
    lua_close(g_L);
    return 0;
}
